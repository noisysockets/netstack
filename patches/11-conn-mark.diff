--- a/pkg/tcpip/stack/packet_buffer.go
+++ b/pkg/tcpip/stack/packet_buffer.go
@@ -161,6 +161,10 @@ type PacketBuffer struct {
 	// NetworkPacketInfo holds an incoming packet's network-layer information.
 	NetworkPacketInfo NetworkPacketInfo
 
+	// ConnMark is an optional packet mark that can be used to associate a
+	// packet with a connection.
+	ConnMark uint32
+
 	tuple *tuple
 
 	// onRelease is a function to be run when the packet buffer is no longer
@@ -389,6 +393,7 @@ func (pk *PacketBuffer) Clone() *PacketBuffer {
 	newPk.NICID = pk.NICID
 	newPk.RXChecksumValidated = pk.RXChecksumValidated
 	newPk.NetworkPacketInfo = pk.NetworkPacketInfo
+	newPk.ConnMark = pk.ConnMark
 	newPk.tuple = pk.tuple
 	newPk.InitRefs()
 	return newPk
--- a/pkg/tcpip/tcpip.go
+++ b/pkg/tcpip/tcpip.go
@@ -1412,6 +1412,14 @@ const (
 	TCPTimeWaitReuseLoopbackOnly
 )
 
+// ConnMarkOption is used by SetSockOpt/GetSockOpt to set/get the
+// connection mark for each packet sent through this socket.
+type ConnMarkOption uint32
+
+func (*ConnMarkOption) isGettableSocketOption() {}
+
+func (*ConnMarkOption) isSettableSocketOption() {}
+
 // LingerOption is used by SetSockOpt/GetSockOpt to set/get the
 // duration for which a socket lingers before returning from Close.
 //
--- a/pkg/tcpip/transport/tcp/accept.go
+++ b/pkg/tcpip/transport/tcp/accept.go
@@ -202,6 +202,7 @@ func (l *listenContext) createConnectingEndpoint(s *segment, rcvdSynOpts header.
 	n.boundNICID = s.pkt.NICID
 	n.route = route
 	n.effectiveNetProtos = []tcpip.NetworkProtocolNumber{s.pkt.NetworkProtocolNumber}
+	n.connMark = s.pkt.ConnMark
 	n.ops.SetReceiveBufferSize(int64(l.rcvWnd), false /* notify */)
 	n.amss = calculateAdvertisedMSS(n.userMSS, n.route)
 	n.setEndpointState(StateConnecting)
--- a/pkg/tcpip/transport/tcp/connect.go
+++ b/pkg/tcpip/transport/tcp/connect.go
@@ -967,6 +967,10 @@ func (e *Endpoint) makeOptions(sackBlocks []header.SACKBlock) []byte {
 func (e *Endpoint) sendEmptyRaw(flags header.TCPFlags, seq, ack seqnum.Value, rcvWnd seqnum.Size) tcpip.Error {
 	pkt := stack.NewPacketBuffer(stack.PacketBufferOptions{})
 	defer pkt.DecRef()
+
+	// Pass throught the connection mark (if set).
+	pkt.ConnMark = e.connMark
+
 	return e.sendRaw(pkt, flags, seq, ack, rcvWnd)
 }

--- a/pkg/tcpip/transport/tcp/endpoint.go
+++ b/pkg/tcpip/transport/tcp/endpoint.go
@@ -582,6 +582,12 @@ type Endpoint struct {
 	// to an out of window segment being received by this endpoint.
 	lastOutOfWindowAckTime tcpip.MonotonicTime
 
+	// connMark is the mark value to be set on outbound packets emitted by this
+	// endpoint. It is used to identify the connection to which the packet belongs.
+	// For servers, if a connMark is set on SYN packets, it is inherited by the
+	// established connection.
+	connMark uint32
+
 	// finWait2Timer is used to reap orphaned sockets in FIN-WAIT-2 where the peer
 	// is yet to send a FIN but on our end the socket is fully closed i.e. endpoint.Close()
 	// has been called on the socket. This timer is not started for sockets that
@@ -2032,6 +2038,11 @@ func (e *Endpoint) SetSockOpt(opt tcpip.SettableSocketOption) tcpip.Error {
 	case *tcpip.SocketDetachFilterOption:
 		return nil
 
+	case *tcpip.ConnMarkOption:
+		e.LockUser()
+		e.connMark = uint32(*v)
+		e.UnlockUser()
+
 	default:
 		return nil
 	}
@@ -2205,6 +2216,11 @@ func (e *Endpoint) GetSockOpt(opt tcpip.GettableSocketOption) tcpip.Error {
 			Port: port,
 		}
 
+	case *tcpip.ConnMarkOption:
+		e.LockUser()
+		*o = tcpip.ConnMarkOption(e.connMark)
+		e.UnlockUser()
+
 	default:
 		return &tcpip.ErrUnknownProtocolOption{}
 	}
--- a/pkg/tcpip/transport/tcp/snd.go
+++ b/pkg/tcpip/transport/tcp/snd.go
@@ -1716,6 +1716,9 @@ func (s *sender) sendSegmentFromPacketBuffer(pkt *stack.PacketBuffer, flags head
 	pkt = pkt.Clone()
 	defer pkt.DecRef()
 
+	// Pass throught the connection mark (if set).
+	pkt.ConnMark = s.ep.connMark
+
 	return s.ep.sendRaw(pkt, flags, seq, rcvNxt, rcvWnd)
 }
 